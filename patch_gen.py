# AUTOGENERATED! DO NOT EDIT! File to edit: patch_gen.ipynb.

# %% auto 0
__all__ = ['PatchGenerator']

# %% patch_gen.ipynb 2
import cv2
import numpy as np
import glob
import os
from tqdm.notebook import tqdm, trange
from joblib import Parallel, delayed

# %% patch_gen.ipynb 3
class PatchGenerator():
    
    def __init__(self, imgs_path: str, patch_size: tuple=(256,256), 
                 max_patches: int=40, min_ratio: float=0.01, 
                 max_black_space: float=0.5, max_trials: int=100, dir_name: str=None):
        
        self.patch_size = patch_size
        self.max_patches = max_patches
        self.min_ratio = min_ratio
        self.imgs_path = glob.glob(f"{imgs_path}/**/*mammo.jpg", recursive=True)
        self.max_trials = max_trials
        self.max_black_space = max_black_space
        
        if dir_name is None:
            dir_name = f"ratio{self.min_ratio}_patches{self.max_patches}_{self.patch_size[0]}x"
        os.makedirs(dir_name, exist_ok=True)
        self.save_path = os.path.join(os.getcwd(), dir_name)
    
    def generate_all(self, n_jobs: int=4):
        
        Parallel(n_jobs=n_jobs) \
            (delayed(self.generate_patches_from_image) \
            (path) for path in tqdm(self.imgs_path, total=len(self.imgs_path)))
        print("Parallel preprocessing done!")
    
    def _save_patch(self, img_patch, patch_type, patch_num, path):
        
        save_path = self._create_save_path(path)
        cv2.imwrite(f'{save_path}/patch_{patch_num}_{patch_type}.jpg', img_patch)   
    
    def generate_patches_from_image(self, path):
         
        for i in range(self.max_patches//2):
            img_patch = self._create_background_patch(path)  
            self._save_patch(img_patch, "BACKGROUND", i, path)
         
        for i in range(self.max_patches):
            img_patch, patch_type = self._create_mass_patch(path)  
            self._save_patch(img_patch, patch_type, i, path)
    
    def _create_background_patch(self, path: str):
        
        ratio = 1
        black_space = 1
        patch_size = self.patch_size
        max_black_space = self.max_black_space
        
        trials = 0
        while (black_space > max_black_space) or (ratio > 0):
            
            if trials >= self.max_trials:
                max_black_space *= 1.5
            
            img = cv2.imread(path,0)
            mask = cv2.imread(path.replace("_mammo.jpg", "_mask.png"),0)

            x = np.random.randint(0, img.shape[1] - patch_size[1])
            y = np.random.randint(0, img.shape[0] - patch_size[0])

            patch_mask = mask[y:y + patch_size[0], x:x + patch_size[1]]
            patch_img = img[y:y + patch_size[0], x:x + patch_size[1]]
            
            black_space = (patch_img==0).mean()
            ratio = (patch_mask!=0).mean()
            trials += 1
            
        #return (patch_img, patch_mask, black_space, ratio)
        
        return patch_img
    
    def _create_mass_patch(self, path: str):
        
        ratio = 0
        patch_size = self.patch_size
        max_black_space = self.max_black_space
        min_ratio = self.min_ratio
        
        trials = 0
        while (ratio < min_ratio) or (black_space > max_black_space):
            
            if trials >= self.max_trials:
                min_ratio *= 0.5
            
            mask = cv2.imread(path.replace("_mammo.jpg", "_mask.png"),0)
            
            roi_coords = np.where(mask!=0)
            expand = int((1-self.min_ratio) * patch_size[0])
            
            ymin, xmin = np.clip(np.min(roi_coords, axis=1) - expand, 0, None)
            ymax, xmax = np.clip(np.max(roi_coords, axis=1) + expand, None, [mask.shape[0], mask.shape[1]])
            roi_mask = mask[ymin:ymax, xmin:xmax]
            
            #return roi_mask

            x = np.random.randint(0, roi_mask.shape[1] - patch_size[1])
            y = np.random.randint(0, roi_mask.shape[0] - patch_size[0])

            patch_mask = roi_mask[y:y + patch_size[0], x:x + patch_size[1]]
            ratio = (patch_mask!=0).mean()
            
            img = cv2.imread(path,0)[ymin:ymax, xmin:xmax]
            patch_img = img[y:y + patch_size[0], x:x + patch_size[1]]
            black_space = (patch_img==0).mean()
            trials += 1
        
        patch_type = self._determine_mass_type(patch_mask)
        
        #return(patch_img, patch_mask, ratio, roi_mask)
        
        return patch_img, patch_type
    
    def _determine_mass_type(self, patch_mask):
        
        mass_only = patch_mask[patch_mask!=0]
        return "BENIGN" if (mass_only==1).mean() > 0.5 else "MALIGNANT"
    
    def _create_save_path(self, path: str):
        
        patient_dir =  path.split(os.path.sep)[-2]
        save_path = f"{self.save_path}/{patient_dir}"
        os.makedirs(save_path, exist_ok=True)
        return save_path
